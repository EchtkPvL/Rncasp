// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: events.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getEventByID = `-- name: GetEventByID :one
SELECT id, name, slug, description, location, participant_count, start_time, end_time, time_granularity, is_locked, is_public, created_by, created_at, updated_at FROM events WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Location,
		&i.ParticipantCount,
		&i.StartTime,
		&i.EndTime,
		&i.TimeGranularity,
		&i.IsLocked,
		&i.IsPublic,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventBySlug = `-- name: GetEventBySlug :one
SELECT id, name, slug, description, location, participant_count, start_time, end_time, time_granularity, is_locked, is_public, created_by, created_at, updated_at FROM events WHERE slug = $1
`

func (q *Queries) GetEventBySlug(ctx context.Context, slug string) (Event, error) {
	row := q.db.QueryRow(ctx, getEventBySlug, slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Location,
		&i.ParticipantCount,
		&i.StartTime,
		&i.EndTime,
		&i.TimeGranularity,
		&i.IsLocked,
		&i.IsPublic,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many
SELECT id, name, slug, description, location, participant_count, start_time, end_time, time_granularity, is_locked, is_public, created_by, created_at, updated_at FROM events ORDER BY start_time DESC
`

func (q *Queries) ListEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Location,
			&i.ParticipantCount,
			&i.StartTime,
			&i.EndTime,
			&i.TimeGranularity,
			&i.IsLocked,
			&i.IsPublic,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (name, slug, description, location, participant_count, start_time, end_time, time_granularity, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, slug, description, location, participant_count, start_time, end_time, time_granularity, is_locked, is_public, created_by, created_at, updated_at
`

type CreateEventParams struct {
	Name             string     `json:"name"`
	Slug             string     `json:"slug"`
	Description      *string    `json:"description"`
	Location         *string    `json:"location"`
	ParticipantCount *int32     `json:"participant_count"`
	StartTime        time.Time  `json:"start_time"`
	EndTime          time.Time  `json:"end_time"`
	TimeGranularity  string     `json:"time_granularity"`
	CreatedBy        *uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Location,
		arg.ParticipantCount,
		arg.StartTime,
		arg.EndTime,
		arg.TimeGranularity,
		arg.CreatedBy,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Location,
		&i.ParticipantCount,
		&i.StartTime,
		&i.EndTime,
		&i.TimeGranularity,
		&i.IsLocked,
		&i.IsPublic,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    location = COALESCE($5, location),
    participant_count = COALESCE($6, participant_count),
    start_time = COALESCE($7, start_time),
    end_time = COALESCE($8, end_time),
    time_granularity = COALESCE($9, time_granularity),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, description, location, participant_count, start_time, end_time, time_granularity, is_locked, is_public, created_by, created_at, updated_at
`

type UpdateEventParams struct {
	ID               uuid.UUID  `json:"id"`
	Name             *string    `json:"name"`
	Slug             *string    `json:"slug"`
	Description      *string    `json:"description"`
	Location         *string    `json:"location"`
	ParticipantCount *int32     `json:"participant_count"`
	StartTime        *time.Time `json:"start_time"`
	EndTime          *time.Time `json:"end_time"`
	TimeGranularity  *string    `json:"time_granularity"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Location,
		arg.ParticipantCount,
		arg.StartTime,
		arg.EndTime,
		arg.TimeGranularity,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Location,
		&i.ParticipantCount,
		&i.StartTime,
		&i.EndTime,
		&i.TimeGranularity,
		&i.IsLocked,
		&i.IsPublic,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const setEventLocked = `-- name: SetEventLocked :exec
UPDATE events SET is_locked = $2, updated_at = NOW() WHERE id = $1
`

func (q *Queries) SetEventLocked(ctx context.Context, id uuid.UUID, isLocked bool) error {
	_, err := q.db.Exec(ctx, setEventLocked, id, isLocked)
	return err
}

const setEventPublic = `-- name: SetEventPublic :exec
UPDATE events SET is_public = $2, updated_at = NOW() WHERE id = $1
`

func (q *Queries) SetEventPublic(ctx context.Context, id uuid.UUID, isPublic bool) error {
	_, err := q.db.Exec(ctx, setEventPublic, id, isPublic)
	return err
}

const listEventTeams = `-- name: ListEventTeams :many
SELECT t.id, t.name, t.abbreviation, t.color, t.sort_order, t.is_active, t.created_at, et.is_visible
FROM teams t
JOIN event_teams et ON t.id = et.team_id
WHERE et.event_id = $1
ORDER BY t.sort_order, t.name
`

type ListEventTeamsRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Abbreviation string    `json:"abbreviation"`
	Color        string    `json:"color"`
	SortOrder    int32     `json:"sort_order"`
	IsActive     bool      `json:"is_active"`
	CreatedAt    time.Time `json:"created_at"`
	IsVisible    bool      `json:"is_visible"`
}

func (q *Queries) ListEventTeams(ctx context.Context, eventID uuid.UUID) ([]ListEventTeamsRow, error) {
	rows, err := q.db.Query(ctx, listEventTeams, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventTeamsRow{}
	for rows.Next() {
		var i ListEventTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Abbreviation,
			&i.Color,
			&i.SortOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.IsVisible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEventTeam = `-- name: SetEventTeam :exec
INSERT INTO event_teams (event_id, team_id, is_visible)
VALUES ($1, $2, $3)
ON CONFLICT (event_id, team_id)
DO UPDATE SET is_visible = EXCLUDED.is_visible
`

type SetEventTeamParams struct {
	EventID   uuid.UUID `json:"event_id"`
	TeamID    uuid.UUID `json:"team_id"`
	IsVisible bool      `json:"is_visible"`
}

func (q *Queries) SetEventTeam(ctx context.Context, arg SetEventTeamParams) error {
	_, err := q.db.Exec(ctx, setEventTeam, arg.EventID, arg.TeamID, arg.IsVisible)
	return err
}

const removeEventTeam = `-- name: RemoveEventTeam :exec
DELETE FROM event_teams WHERE event_id = $1 AND team_id = $2
`

func (q *Queries) RemoveEventTeam(ctx context.Context, eventID uuid.UUID, teamID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeEventTeam, eventID, teamID)
	return err
}

const listEventAdmins = `-- name: ListEventAdmins :many
SELECT u.id, u.username, u.full_name, u.display_name, u.email
FROM users u
JOIN event_admins ea ON u.id = ea.user_id
WHERE ea.event_id = $1
ORDER BY u.username
`

type ListEventAdminsRow struct {
	ID          uuid.UUID `json:"id"`
	Username    string    `json:"username"`
	FullName    string    `json:"full_name"`
	DisplayName *string   `json:"display_name"`
	Email       *string   `json:"email"`
}

func (q *Queries) ListEventAdmins(ctx context.Context, eventID uuid.UUID) ([]ListEventAdminsRow, error) {
	rows, err := q.db.Query(ctx, listEventAdmins, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventAdminsRow{}
	for rows.Next() {
		var i ListEventAdminsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.DisplayName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addEventAdmin = `-- name: AddEventAdmin :exec
INSERT INTO event_admins (event_id, user_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

func (q *Queries) AddEventAdmin(ctx context.Context, eventID uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, addEventAdmin, eventID, userID)
	return err
}

const removeEventAdmin = `-- name: RemoveEventAdmin :exec
DELETE FROM event_admins WHERE event_id = $1 AND user_id = $2
`

func (q *Queries) RemoveEventAdmin(ctx context.Context, eventID uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeEventAdmin, eventID, userID)
	return err
}

const isEventAdmin = `-- name: IsEventAdmin :one
SELECT EXISTS(SELECT 1 FROM event_admins WHERE event_id = $1 AND user_id = $2)
`

func (q *Queries) IsEventAdmin(ctx context.Context, eventID uuid.UUID, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isEventAdmin, eventID, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listEventPinnedUsers = `-- name: ListEventPinnedUsers :many
SELECT u.id, u.username, u.full_name, u.display_name
FROM users u
JOIN event_pinned_users ep ON u.id = ep.user_id
WHERE ep.event_id = $1
ORDER BY u.username
`

type ListEventPinnedUsersRow struct {
	ID          uuid.UUID `json:"id"`
	Username    string    `json:"username"`
	FullName    string    `json:"full_name"`
	DisplayName *string   `json:"display_name"`
}

func (q *Queries) ListEventPinnedUsers(ctx context.Context, eventID uuid.UUID) ([]ListEventPinnedUsersRow, error) {
	rows, err := q.db.Query(ctx, listEventPinnedUsers, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventPinnedUsersRow{}
	for rows.Next() {
		var i ListEventPinnedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addEventPinnedUser = `-- name: AddEventPinnedUser :exec
INSERT INTO event_pinned_users (event_id, user_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

func (q *Queries) AddEventPinnedUser(ctx context.Context, eventID uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, addEventPinnedUser, eventID, userID)
	return err
}

const removeEventPinnedUser = `-- name: RemoveEventPinnedUser :exec
DELETE FROM event_pinned_users WHERE event_id = $1 AND user_id = $2
`

func (q *Queries) RemoveEventPinnedUser(ctx context.Context, eventID uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeEventPinnedUser, eventID, userID)
	return err
}

const listEventHiddenRanges = `-- name: ListEventHiddenRanges :many
SELECT id, event_id, hide_start_hour, hide_end_hour FROM event_hidden_ranges WHERE event_id = $1 ORDER BY hide_start_hour
`

func (q *Queries) ListEventHiddenRanges(ctx context.Context, eventID uuid.UUID) ([]EventHiddenRange, error) {
	rows, err := q.db.Query(ctx, listEventHiddenRanges, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventHiddenRange{}
	for rows.Next() {
		var i EventHiddenRange
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.HideStartHour,
			&i.HideEndHour,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEventHiddenRange = `-- name: SetEventHiddenRange :one
INSERT INTO event_hidden_ranges (event_id, hide_start_hour, hide_end_hour)
VALUES ($1, $2, $3)
RETURNING id, event_id, hide_start_hour, hide_end_hour
`

type SetEventHiddenRangeParams struct {
	EventID       uuid.UUID `json:"event_id"`
	HideStartHour int32     `json:"hide_start_hour"`
	HideEndHour   int32     `json:"hide_end_hour"`
}

func (q *Queries) SetEventHiddenRange(ctx context.Context, arg SetEventHiddenRangeParams) (EventHiddenRange, error) {
	row := q.db.QueryRow(ctx, setEventHiddenRange, arg.EventID, arg.HideStartHour, arg.HideEndHour)
	var i EventHiddenRange
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.HideStartHour,
		&i.HideEndHour,
	)
	return i, err
}

const deleteEventHiddenRanges = `-- name: DeleteEventHiddenRanges :exec
DELETE FROM event_hidden_ranges WHERE event_id = $1
`

func (q *Queries) DeleteEventHiddenRanges(ctx context.Context, eventID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventHiddenRanges, eventID)
	return err
}
