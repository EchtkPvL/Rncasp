// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: ical_tokens.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createICalToken = `-- name: CreateICalToken :one
INSERT INTO ical_tokens (user_id, token_hash, label, scope, event_id, team_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, token_hash, label, scope, event_id, team_id, created_at, last_used_at, is_active
`

type CreateICalTokenParams struct {
	UserID    uuid.UUID  `json:"user_id"`
	TokenHash string     `json:"token_hash"`
	Label     string     `json:"label"`
	Scope     string     `json:"scope"`
	EventID   *uuid.UUID `json:"event_id"`
	TeamID    *uuid.UUID `json:"team_id"`
}

func (q *Queries) CreateICalToken(ctx context.Context, arg CreateICalTokenParams) (IcalToken, error) {
	row := q.db.QueryRow(ctx, createICalToken,
		arg.UserID,
		arg.TokenHash,
		arg.Label,
		arg.Scope,
		arg.EventID,
		arg.TeamID,
	)
	var i IcalToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Label,
		&i.Scope,
		&i.EventID,
		&i.TeamID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.IsActive,
	)
	return i, err
}

const listICalTokensByUser = `-- name: ListICalTokensByUser :many
SELECT id, user_id, token_hash, label, scope, event_id, team_id, created_at, last_used_at, is_active FROM ical_tokens
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListICalTokensByUser(ctx context.Context, userID uuid.UUID) ([]IcalToken, error) {
	rows, err := q.db.Query(ctx, listICalTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IcalToken{}
	for rows.Next() {
		var i IcalToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.Label,
			&i.Scope,
			&i.EventID,
			&i.TeamID,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getICalTokenByHash = `-- name: GetICalTokenByHash :one
SELECT it.id, it.user_id, it.token_hash, it.label, it.scope, it.event_id, it.team_id, it.created_at, it.last_used_at, it.is_active, u.username
FROM ical_tokens it
JOIN users u ON it.user_id = u.id
WHERE it.token_hash = $1 AND it.is_active = true
`

type GetICalTokenByHashRow struct {
	ID         uuid.UUID  `json:"id"`
	UserID     uuid.UUID  `json:"user_id"`
	TokenHash  string     `json:"token_hash"`
	Label      string     `json:"label"`
	Scope      string     `json:"scope"`
	EventID    *uuid.UUID `json:"event_id"`
	TeamID     *uuid.UUID `json:"team_id"`
	CreatedAt  time.Time  `json:"created_at"`
	LastUsedAt *time.Time `json:"last_used_at"`
	IsActive   bool       `json:"is_active"`
	Username   string     `json:"username"`
}

func (q *Queries) GetICalTokenByHash(ctx context.Context, tokenHash string) (GetICalTokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getICalTokenByHash, tokenHash)
	var i GetICalTokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Label,
		&i.Scope,
		&i.EventID,
		&i.TeamID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.IsActive,
		&i.Username,
	)
	return i, err
}

const revokeICalToken = `-- name: RevokeICalToken :exec
UPDATE ical_tokens SET is_active = false WHERE id = $1 AND user_id = $2
`

func (q *Queries) RevokeICalToken(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeICalToken, id, userID)
	return err
}

const updateICalTokenLastUsed = `-- name: UpdateICalTokenLastUsed :exec
UPDATE ical_tokens SET last_used_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateICalTokenLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateICalTokenLastUsed, id)
	return err
}
