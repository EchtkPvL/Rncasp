// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: ical_tokens.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createICalToken = `-- name: CreateICalToken :one
INSERT INTO ical_tokens (user_id, token_hash, token, label, scope, event_id, team_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, token_hash, token, label, scope, event_id, team_id, created_at, last_used_at, is_active
`

type CreateICalTokenParams struct {
	UserID    uuid.UUID  `json:"user_id"`
	TokenHash string     `json:"token_hash"`
	Token     string     `json:"token"`
	Label     string     `json:"label"`
	Scope     string     `json:"scope"`
	EventID   *uuid.UUID `json:"event_id"`
	TeamID    *uuid.UUID `json:"team_id"`
}

func (q *Queries) CreateICalToken(ctx context.Context, arg CreateICalTokenParams) (IcalToken, error) {
	row := q.db.QueryRow(ctx, createICalToken,
		arg.UserID,
		arg.TokenHash,
		arg.Token,
		arg.Label,
		arg.Scope,
		arg.EventID,
		arg.TeamID,
	)
	var i IcalToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Label,
		&i.Scope,
		&i.EventID,
		&i.TeamID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.IsActive,
	)
	return i, err
}

const listICalTokensByUser = `-- name: ListICalTokensByUser :many
SELECT it.id, it.user_id, it.token_hash, it.token, it.label, it.scope, it.event_id, it.team_id, it.created_at, it.last_used_at, it.is_active,
       e.slug AS event_slug,
       t.abbreviation AS team_abbreviation
FROM ical_tokens it
LEFT JOIN events e ON it.event_id = e.id
LEFT JOIN teams t ON it.team_id = t.id
WHERE it.user_id = $1 AND it.is_active = true
ORDER BY it.created_at DESC
`

type ListICalTokensByUserRow struct {
	ID               uuid.UUID  `json:"id"`
	UserID           uuid.UUID  `json:"user_id"`
	TokenHash        string     `json:"token_hash"`
	Token            string     `json:"token"`
	Label            string     `json:"label"`
	Scope            string     `json:"scope"`
	EventID          *uuid.UUID `json:"event_id"`
	TeamID           *uuid.UUID `json:"team_id"`
	CreatedAt        time.Time  `json:"created_at"`
	LastUsedAt       *time.Time `json:"last_used_at"`
	IsActive         bool       `json:"is_active"`
	EventSlug        *string    `json:"event_slug"`
	TeamAbbreviation *string    `json:"team_abbreviation"`
}

func (q *Queries) ListICalTokensByUser(ctx context.Context, userID uuid.UUID) ([]ListICalTokensByUserRow, error) {
	rows, err := q.db.Query(ctx, listICalTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListICalTokensByUserRow{}
	for rows.Next() {
		var i ListICalTokensByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.Token,
			&i.Label,
			&i.Scope,
			&i.EventID,
			&i.TeamID,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.IsActive,
			&i.EventSlug,
			&i.TeamAbbreviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getICalTokenByHash = `-- name: GetICalTokenByHash :one
SELECT it.id, it.user_id, it.token_hash, it.token, it.label, it.scope, it.event_id, it.team_id, it.created_at, it.last_used_at, it.is_active, u.username
FROM ical_tokens it
JOIN users u ON it.user_id = u.id
WHERE it.token_hash = $1 AND it.is_active = true
`

type GetICalTokenByHashRow struct {
	ID         uuid.UUID  `json:"id"`
	UserID     uuid.UUID  `json:"user_id"`
	TokenHash  string     `json:"token_hash"`
	Token      string     `json:"token"`
	Label      string     `json:"label"`
	Scope      string     `json:"scope"`
	EventID    *uuid.UUID `json:"event_id"`
	TeamID     *uuid.UUID `json:"team_id"`
	CreatedAt  time.Time  `json:"created_at"`
	LastUsedAt *time.Time `json:"last_used_at"`
	IsActive   bool       `json:"is_active"`
	Username   string     `json:"username"`
}

func (q *Queries) GetICalTokenByHash(ctx context.Context, tokenHash string) (GetICalTokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getICalTokenByHash, tokenHash)
	var i GetICalTokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Label,
		&i.Scope,
		&i.EventID,
		&i.TeamID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.IsActive,
		&i.Username,
	)
	return i, err
}

const revokeICalToken = `-- name: RevokeICalToken :exec
UPDATE ical_tokens SET is_active = false WHERE id = $1 AND user_id = $2
`

func (q *Queries) RevokeICalToken(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeICalToken, id, userID)
	return err
}

const updateICalTokenLastUsed = `-- name: UpdateICalTokenLastUsed :exec
UPDATE ical_tokens SET last_used_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateICalTokenLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateICalTokenLastUsed, id)
	return err
}
