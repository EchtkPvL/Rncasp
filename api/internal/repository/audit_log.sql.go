// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: audit_log.sql

package repository

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createAuditLogEntry = `-- name: CreateAuditLogEntry :one
INSERT INTO audit_log (user_id, event_id, action, entity_type, entity_id, old_value, new_value, ip_address)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, event_id, action, entity_type, entity_id, old_value, new_value, ip_address, created_at
`

type CreateAuditLogEntryParams struct {
	UserID     *uuid.UUID      `json:"user_id"`
	EventID    *uuid.UUID      `json:"event_id"`
	Action     string          `json:"action"`
	EntityType string          `json:"entity_type"`
	EntityID   *uuid.UUID      `json:"entity_id"`
	OldValue   json.RawMessage `json:"old_value"`
	NewValue   json.RawMessage `json:"new_value"`
	IpAddress  *string         `json:"ip_address"`
}

func (q *Queries) CreateAuditLogEntry(ctx context.Context, arg CreateAuditLogEntryParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLogEntry,
		arg.UserID,
		arg.EventID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldValue,
		arg.NewValue,
		arg.IpAddress,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValue,
		&i.NewValue,
		&i.IpAddress,
		&i.CreatedAt,
	)
	return i, err
}

const listAuditLog = `-- name: ListAuditLog :many
SELECT al.id, al.user_id, al.event_id, al.action, al.entity_type, al.entity_id, al.old_value, al.new_value, al.ip_address, al.created_at, u.username
FROM audit_log al
LEFT JOIN users u ON al.user_id = u.id
WHERE ($1::uuid IS NULL OR al.event_id = $1)
  AND ($2::uuid IS NULL OR al.user_id = $2)
  AND ($3::varchar IS NULL OR al.action = $3)
  AND ($4::varchar IS NULL OR al.entity_type = $4)
ORDER BY al.created_at DESC
LIMIT $5 OFFSET $6
`

type ListAuditLogParams struct {
	EventID    *uuid.UUID `json:"event_id"`
	UserID     *uuid.UUID `json:"user_id"`
	Action     *string    `json:"action"`
	EntityType *string    `json:"entity_type"`
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
}

type ListAuditLogRow struct {
	ID         uuid.UUID       `json:"id"`
	UserID     *uuid.UUID      `json:"user_id"`
	EventID    *uuid.UUID      `json:"event_id"`
	Action     string          `json:"action"`
	EntityType string          `json:"entity_type"`
	EntityID   *uuid.UUID      `json:"entity_id"`
	OldValue   json.RawMessage `json:"old_value"`
	NewValue   json.RawMessage `json:"new_value"`
	IpAddress  *string         `json:"ip_address"`
	CreatedAt  time.Time       `json:"created_at"`
	Username   *string         `json:"username"`
}

func (q *Queries) ListAuditLog(ctx context.Context, arg ListAuditLogParams) ([]ListAuditLogRow, error) {
	rows, err := q.db.Query(ctx, listAuditLog,
		arg.EventID,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditLogRow{}
	for rows.Next() {
		var i ListAuditLogRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EventID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValue,
			&i.NewValue,
			&i.IpAddress,
			&i.CreatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
