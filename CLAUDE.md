# CLAUDE.md - Project Guide for AI Agents

## Project Overview

**Rncasp** (Really no clue about shift planning) is a shift planning web application for LAN party events. It replaces an Excel-based workflow where team members sign up for shifts across multi-day events (3-7+ days). The core UI is a grid with team members as rows and time slots as columns, where each cell shows a single-letter team code with a team color background.

## Tech Stack

| Layer | Technology |
|-------|-----------|
| Backend | Go 1.23+ with Chi v5 router |
| DB Access | sqlc + pgx v5 |
| Migrations | goose v3 (SQL files in `api/migrations/`) |
| Database | PostgreSQL 17 |
| Sessions/Cache | Redis 7 |
| Frontend | React 19 + TypeScript + Vite |
| UI | Tailwind CSS v4 with CSS custom properties |
| State | TanStack Query v5 |
| Drag & Drop | dnd-kit |
| i18n | react-i18next (frontend), go-i18n (backend emails) |
| Real-time | SSE (Server-Sent Events) with Redis Pub/Sub |

## Architecture

### Backend: Handler -> Service -> Repository

```
HTTP Request
  -> middleware (auth, audit, rate limit, CORS, request ID)
    -> handler (parse request, validate input format)
      -> service (business logic, permission checks)
        -> repository (sqlc-generated database queries)
```

- **Handlers** are thin: parse JSON, call service, return response. No business logic.
- **Services** contain all business rules: permission checks, overlap detection, overbooking prevention, event locking enforcement.
- **Repository** is auto-generated by sqlc from SQL queries. Never edit generated files.

### Frontend: Page -> Component -> Hook -> API

```
Page component
  -> TanStack Query hooks (useShifts, useEvents, etc.)
    -> API client functions (fetch with credentials)
  -> SSE hook (useSSE) triggers cache invalidation on server events
```

## Project Structure

```
api/                              # Go backend
  cmd/server/main.go              # Entry point
  internal/
    config/config.go              # Env-based configuration
    server/server.go, routes.go   # HTTP server + route registration
    server/middleware/             # auth, cors, audit, ratelimit, requestid
    handler/                      # HTTP handlers (thin)
    service/                      # Business logic layer
    repository/
      queries/                    # sqlc SQL query files (EDIT THESE)
      db.go, models.go, *.sql.go  # sqlc GENERATED (DO NOT EDIT)
    model/                        # Domain errors, DTOs, response helpers
    sse/broker.go                 # SSE event broadcasting
    mail/                         # SMTP mailer + HTML templates
    webhook/dispatcher.go
    ical/generator.go
  migrations/                     # goose SQL migration files

web/                              # React frontend
  src/
    api/                          # API client functions and TypeScript types
    hooks/                        # TanStack Query hooks
    components/
      grid/                       # ShiftGrid, TimeRuler, GridRow, ShiftBlock, CoverageBar
      shifts/                     # CreateShiftDialog, ShiftDetailDialog
      events/                     # EventCard, EventList
      availability/               # AvailabilityEditor
      export/                     # ExportMenu, PrintGridPage, PrintListPage
      common/                     # DateTimePicker, LanguageSwitcher, ErrorBoundary
      layout/                     # AppLayout, Navbar
    pages/                        # Route-level page components
    contexts/AuthContext.tsx       # Auth state, login/logout
    lib/                          # Utilities (time.ts, permissions.ts)
    i18n/config.ts
  public/locales/{en,de}/         # Translation JSON files (5 namespaces)
```

## Build & Run Commands

```bash
# Development (full stack via Docker)
make dev
# API: http://localhost:3000, Web: http://localhost:5173, Mailpit: http://localhost:8025
# Postgres: localhost:5432, Redis: localhost:6379, Mailpit SMTP: localhost:1025

# Or manually
docker compose -f docker-compose.yml -f docker-compose.dev.yml up

# Type-check frontend
cd web && npx tsc --noEmit

# Build backend
cd api && go build ./...

# Run database migrations
make migrate

# Regenerate sqlc code (after changing SQL queries)
make sqlc
# Or: cd api && sqlc generate

# Production build
docker compose up -d --build

# Release (triggers GitHub Actions to build + push images to ghcr.io)
make release VERSION=v1.0.0
```

## Do's

### General
- **Read code before modifying it.** Understand existing patterns before making changes.
- **Follow existing patterns.** Look at how similar features are implemented before adding new ones.
- **Keep changes minimal.** Only modify what's necessary for the task at hand.
- **Use CSS custom properties for colors** (`var(--color-primary)`, etc.). Never hardcode color values.
- **Test your changes compile**: `cd api && go build ./...` and `cd web && npx tsc --noEmit`.

### Backend (Go)
- **Write SQL queries in `api/internal/repository/queries/*.sql`**, then run `make sqlc` or `sqlc generate` to regenerate Go code.
- **Keep handlers thin**: parse request, call service, write response. All logic goes in services.
- **Use domain errors** from `model/` package (`model.NewDomainError`, `model.NewFieldError`) for business rule violations.
- **Use `model.JSON(w, statusCode, data)`** for responses and `model.ErrorResponse(w, err)` for errors.
- **Validate inputs in services**, not handlers. Handlers only validate request format.
- **Use pointer types (`*string`, `*bool`)** for optional/nullable update fields in request structs. This distinguishes "not provided" from "set to zero value".
- **Use `COALESCE(sqlc.narg('field'), field)` pattern** in UPDATE queries so unset fields keep their current value.
- **Add new migration files** (e.g., `005_description.sql`) with goose format for schema changes. Migrations auto-apply on startup.

### Frontend (React/TypeScript)
- **Use TanStack Query hooks** for all API data fetching. Create hooks in `web/src/hooks/`.
- **Use `useTranslation`** with namespaces: `common`, `events`, `shifts`, `admin`, `settings`.
- **Add translation keys to both `en/` and `de/` JSON files** when adding user-visible strings.
- **Use `useAuth()` context** to access the current user and auth state.
- **Use the `DateTimePicker` component** (in `components/common/`) instead of native `<input type="datetime-local">` when granularity matters.
- **Use `useTimeFormat()` hook** when formatting times to respect the user's 12h/24h preference.
- **Use `formatSlotTime(date, hour12)` from `lib/time.ts`** for consistent time formatting.
- **Use existing API client pattern** in `web/src/api/` â€” fetch with credentials, throw `ApiError` on failure.

### i18n
- **5 translation namespaces**: `common` (shared UI), `events` (event-related), `shifts` (shift/grid-related), `admin` (admin pages), `settings` (user settings pages).
- **Translation files live in** `web/public/locales/{en,de}/{namespace}.json`.
- **Always add keys to both `en` and `de` files.** German translations should be natural, not machine-translated.
- **Reference keys with namespace prefix**: `t("admin:users.title")`, `t("common:save")`.

### Database
- **All IDs are UUIDs.** All timestamps are `TIMESTAMPTZ` (stored as UTC).
- **Shifts are stored as time ranges** (start_time, end_time), not per-slot records. The grid snaps to event granularity.
- **Coverage requirements are time-varying**: different time ranges can have different required counts per team.
- **Event locking is togglable**: events can be locked and unlocked multiple times.

## Don'ts

### Critical
- **NEVER edit sqlc-generated files** (`db.go`, `models.go`, `*.sql.go` in `api/internal/repository/`). Modify the SQL in `queries/*.sql` and regenerate. If `sqlc` is not available locally, you may manually update generated files to match what sqlc would produce, but note this in a comment.
- **NEVER hardcode colors.** Use CSS custom properties (`var(--color-primary)`, `var(--color-border)`, etc.) that come from the dynamic color palette.
- **NEVER put business logic in handlers.** Handlers parse requests and call services. Services enforce rules.
- **NEVER use `confirm()` or `alert()` in the frontend.** Use translatable UI components instead.

### Code Quality
- **Don't add unnecessary abstractions.** A simple function call is better than a premature wrapper.
- **Don't add features beyond what's requested.** Stay focused on the task.
- **Don't add docstrings/comments to code you didn't change.**
- **Don't add error handling for scenarios that can't happen.** Trust internal code paths; only validate at boundaries (user input, API responses).
- **Don't create new files when editing an existing one would suffice.**

### Git
- **Don't commit `.env`, credentials, or secrets.**
- **Don't push to remote unless explicitly asked.**
- **Don't amend commits unless explicitly asked.** Create new commits.

## Permission Model

| Role | Scope | Capabilities |
|------|-------|-------------|
| Super-admin | Global | Everything: users, events, teams, OAuth, SMTP, settings, locked events |
| Event admin | Per-event | Edit shifts + settings for assigned events. Cannot delete events or manage users |
| User | Global | Self-signup for shifts, edit own shifts. Cannot overbook past coverage |
| Read-only | Global | View only |

**Dummy accounts** (`account_type='dummy'`): placeholder users that cannot log in, assignable to shifts by admins.

**Account types**: `local` (password login), `oauth` (external provider), `dummy` (no login). Conversions between local and dummy are supported (dummy->local requires setting a password; local->dummy clears the password).

## Key Design Decisions

- **SSE over WebSockets**: simpler, auto-reconnect, sufficient for server-to-client push. Redis Pub/Sub for multi-instance.
- **CSS @media print + server-side PDF**: browser-first printing with A4/A3 support. Server-side PDF export via chromedp as an alternative.
- **Optimistic updates for DnD**: TanStack Query `onMutate` updates cache immediately, `onError` rolls back. No perceived lag.
- **Hidden teams**: `is_visible` on `event_teams` hides teams from statistics only. Hidden team shifts still appear in the grid.
- **Time format**: user-level preference (`24h`/`12h`) stored in DB. Components use `useTimeFormat()` hook.
- **DateTimePicker**: custom component with granularity-aware minute selection (15min/30min/1hour) replaces native `datetime-local`.

## Common Patterns

### Adding a new API endpoint (end-to-end)
1. Migration in `api/migrations/` (if schema change needed)
2. SQL query in `api/internal/repository/queries/`, then `sqlc generate`
3. Service method in `api/internal/service/` (business logic)
4. Handler method in `api/internal/handler/` (thin HTTP layer)
5. Register route in `api/internal/server/routes.go`
6. TypeScript types in `web/src/api/types.ts`
7. API client function in `web/src/api/`
8. TanStack Query hook in `web/src/hooks/`
9. React component/page in `web/src/components/` or `web/src/pages/`
10. Translation keys in `web/public/locales/{en,de}/`

### Update query pattern (sqlc)
```sql
-- name: UpdateUser :one
UPDATE users SET
  role = COALESCE(sqlc.narg('role'), role),
  is_active = COALESCE(sqlc.narg('is_active'), is_active),
  full_name = COALESCE(sqlc.narg('full_name'), full_name),
  updated_at = NOW()
WHERE id = @id
RETURNING *;
```

### Service update pattern (Go)
```go
type UpdateUserInput struct {
    Role     *string  // nil = don't change, pointer = new value
    IsActive *bool
    FullName *string
}
```

### Frontend API call pattern
```typescript
// api/users.ts
export async function updateUser(userId: string, data: Record<string, unknown>) {
  return fetchApi<User>(`/api/users/${userId}`, { method: "PUT", body: JSON.stringify(data) });
}

// hooks/useUsers.ts
export function useUpdateUser() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: ({ userId, data }) => updateUser(userId, data),
    onSuccess: () => { qc.invalidateQueries({ queryKey: ["users"] }); },
  });
}
```

## Database Schema (Key Tables)

```
users:          id, username, full_name, display_name, email, password_hash, role(super_admin|user|read_only),
                language(en|de), account_type(local|oauth|dummy), totp_secret, totp_enabled, is_active,
                time_format(24h|12h)

oauth_providers: id, name, client_id, client_secret, authorize_url, token_url, userinfo_url, scopes, is_enabled
oauth_connections: id, user_id, provider_id, external_id, access_token, refresh_token
sessions:       id, user_id, token_hash, ip_address, user_agent, expires_at

teams:          id, name, abbreviation(1 char), color(hex), sort_order, is_active

events:         id, name, slug(unique), description, location, participant_count,
                start_time, end_time, time_granularity(15min|30min|1hour),
                is_locked, is_public, created_by
event_teams:    event_id, team_id, is_visible
event_admins:   event_id, user_id
event_hidden_ranges: id, event_id, hide_start_hour, hide_end_hour

shifts:         id, event_id, team_id, user_id, start_time, end_time, created_by
coverage_requirements: id, event_id, team_id, start_time, end_time, required_count

user_availability: id, event_id, user_id, start_time, end_time, status(available|preferred|unavailable), note

ical_tokens:    id, user_id, token_hash, label, scope(user|event_all|event_team),
                event_id(nullable), team_id(nullable), created_at, last_used_at, is_active

notifications:  id, user_id, event_id, title, body, trigger_type, is_read
notification_preferences: user_id, trigger_type, channel(in_app|email|webhook), is_enabled
webhook_configs: id, event_id, name, url, secret, trigger_types[], is_enabled

audit_log:      id, user_id, event_id, action(create|update|delete|login|lock|unlock),
                entity_type, entity_id, old_value(jsonb), new_value(jsonb), ip_address, created_at

smtp_config:    (singleton) host, port, username, password, from_address, from_name, use_tls
app_settings:   key, value(jsonb) -- app_name, registration_enabled, color_palette, etc.
```

## Default Color Palette

Stored in `app_settings` table, editable by super-admins in the admin UI. The frontend reads the palette from the API on load and injects it as CSS custom properties (`--color-primary`, etc.).

```json
{
  "primary": "#e26729", "primaryDark": "#c4551f",
  "background": "#303030", "surface": "#f4f4f4", "surfaceAlt": "#efefef",
  "textPrimary": "#000000", "textSecondary": "#818181",
  "textOnPrimary": "#ffffff", "textOnDark": "#ffffff",
  "border": "#cccccc",
  "error": "#b20101", "warning": "#FAE55F", "success": "#2d8a4e", "info": "#5bbad5",
  "navBackground": "#303030", "navText": "#ffffff",
  "buttonPrimary": "#e26729", "buttonSecondary": "#818181"
}
```

## Key API Endpoints

```
# Auth
POST   /api/auth/register, /api/auth/login, /api/auth/logout
GET    /api/auth/oauth/{provider}, /api/auth/oauth/{provider}/callback
POST   /api/auth/totp/setup, /api/auth/totp/verify
DELETE /api/auth/totp
GET    /api/auth/me
PUT    /api/auth/profile

# Users
GET    /api/users                    GET  /api/users/search
GET    /api/users/me/shifts
POST   /api/users/dummy
GET    /api/users/{id}               PUT  /api/users/{id}               DELETE /api/users/{id}

# Events
GET    /api/events                   POST /api/events
GET    /api/events/{slug}            PUT  /api/events/{slug}            DELETE /api/events/{slug}
PUT    /api/events/{slug}/lock       PUT  /api/events/{slug}/public
GET    /api/events/{slug}/admins     POST /api/events/{slug}/admins     DELETE /api/events/{slug}/admins/{userId}
PUT    /api/events/{slug}/teams

# Teams
GET    /api/teams                    POST /api/teams
PUT    /api/teams/{id}               DELETE /api/teams/{id}

# Shifts
GET    /api/events/{slug}/shifts     POST /api/events/{slug}/shifts
PUT    /api/events/{slug}/shifts/{id}  DELETE /api/events/{slug}/shifts/{id}

# Coverage
GET    /api/events/{slug}/coverage   PUT  /api/events/{slug}/coverage

# Availability
GET    /api/events/{slug}/availability
PUT    /api/events/{slug}/availability/mine
PUT    /api/events/{slug}/availability/{userId}

# iCal Tokens (user settings)
GET    /api/ical-tokens              POST /api/ical-tokens              DELETE /api/ical-tokens/{id}

# iCal Subscriptions (no auth, token in URL)
GET    /ical/user/{uuid}/{token}
GET    /ical/event/{slug}/all/{token}
GET    /ical/event/{slug}/{team_abbr}/{token}

# Notifications
GET    /api/notifications            PUT  /api/notifications/{id}/read  PUT /api/notifications/read-all
GET    /api/notifications/preferences  PUT /api/notifications/preferences

# SSE
GET    /api/sse

# Exports
GET    /api/events/{slug}/export/csv
GET    /api/events/{slug}/export/ical
GET    /api/events/{slug}/export/pdf

# Admin
GET    /api/admin/oauth-providers    POST/PUT/DELETE /api/admin/oauth-providers/{id}
GET    /api/admin/smtp               PUT  /api/admin/smtp               POST /api/admin/smtp/test
GET    /api/admin/audit-log
GET    /api/admin/settings           PUT  /api/admin/settings
GET    /api/admin/webhooks           POST/PUT/DELETE /api/admin/webhooks/{id}
GET    /api/admin/dashboard

# Public
GET    /api/public/events/{slug}     GET  /api/public/events/{slug}/grid
GET    /api/public/events/{slug}/export/pdf
GET    /api/settings/public

# Health
GET    /api/health
```

## Verification Checklist

1. `docker compose up` starts all services, API healthy, DB migrated
2. Register first user -> auto super-admin
3. Create teams (Bar, Catering, etc.) with colors
4. Create event with slug, set time granularity
5. Assign event admins, hide/show teams per event
6. Create shifts via grid click and drag-drop
7. Verify coverage indicators (red/green/yellow)
8. Test all 4 views (everything, per-team, per-day, per-user)
9. Self-signup as regular user, verify overbooking prevention
10. Lock event -> only super-admin can edit; unlock -> edit works again
11. Enable public access -> unauthenticated slug URL works
12. Test OAuth2 login, TOTP setup
13. Verify SSE real-time updates across two browser tabs
14. Export CSV, verify content
15. Create iCal token, subscribe in calendar app, verify shifts appear
16. Print in A4/A3, verify pagination and layout
17. Switch language DE<->EN, verify all strings
18. Change color palette in admin, verify UI updates
19. Check audit log for all changes
20. Test on mobile browser (bottom-sheet dialogs, hamburger menu)
21. Test time format preference (switch between 12h/24h in profile)
22. Test username editing and account type conversion (dummy<->local)
23. Test availability editor (mark slots, verify grid tinting)
